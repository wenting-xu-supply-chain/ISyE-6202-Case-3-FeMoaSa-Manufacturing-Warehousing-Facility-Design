import pandas as pd
import numpy as np
from scipy.stats import norm
import os

# ============================================================
# Georgia Tech ISyE 6202 & 6335 - Casework 3
# Task 1: Capacity Plan (Annual + Weekly + Robust)
# - Keeps per-part ANNUAL mean & std
# - Adds per-part WEEKLY mean & std
# - Adds WEEKLY Robust (99.5%) mirroring ANNUAL Robust
# - Preserves natural order P1..P20
# - Uses the LATEST uploaded Excel filename
# - NEW: Adds product-level weekly avg/std and parts-by-family weekly avg tables
# ============================================================

# ------------------ Tunables / Constants -------------------
EFFICIENCY = 0.90
RELIABILITY = 0.98
SERVICE_LEVEL = 0.995         # OTIF target
Z_SCORE = norm.ppf(SERVICE_LEVEL)  # ≈ 2.576
WEEKS_PER_YEAR = 52.0
PRODUCT_FAMILIES = ['A1', 'A2', 'A3', 'B1', 'B2']

# ------------------ Paths (Update-safe) --------------------
EXCEL_PATH = "iSYE 6202 & 6335 2025 Casework 3 FaMoaSa Facility Design - Tables and Basic Layouts.xlsx"
OUT_DIR = "Task1_Outcome"

# ------------------ Helpers -------------------------------
def natural_sort_index(idx):
    """Return labels sorted like P1, P2, ..., P10 by numeric suffix."""
    def key(label):
        s = str(label)
        num = ''.join(ch for ch in s if ch.isdigit())
        return (s.rstrip(num), int(num) if num.isdigit() else float('inf'))
    return sorted(idx, key=key)

def ensure_cols(df, cols):
    missing = [c for c in cols if c not in df.columns]
    if missing:
        raise KeyError(f"Missing columns {missing} in DataFrame with columns {list(df.columns)}")

# ------------------ Main Pipeline -------------------------
def main():
    os.makedirs(OUT_DIR, exist_ok=True)
    if not os.path.exists(EXCEL_PATH):
        raise FileNotFoundError(f"Excel file not found at: {EXCEL_PATH}")

    # === 1) Read +1 Year Product Demand (ANNUAL mean) ===
    # Average table header ≈ row 17 -> header=16
    demand_avg_raw = pd.read_excel(EXCEL_PATH, sheet_name="+1 Year Product Demand", header=16)
    ensure_cols(demand_avg_raw, ['Year'] + PRODUCT_FAMILIES)
    demand_avg = demand_avg_raw[['Year'] + PRODUCT_FAMILIES].dropna()
    demand_avg = demand_avg[demand_avg['Year'].astype(str).str.startswith('+')].reset_index(drop=True)
    if demand_avg.empty:
        raise ValueError("No '+#' rows found in the average demand block.")
    product_demand_avg = demand_avg.iloc[0][PRODUCT_FAMILIES].astype(float)

    # === 2) Read +1 Year Product Demand (ANNUAL std) ===
    # Std block header ≈ row 22 -> header=21
    demand_std_raw = pd.read_excel(EXCEL_PATH, sheet_name="+1 Year Product Demand", header=21)
    ensure_cols(demand_std_raw, ['Year'] + PRODUCT_FAMILIES)
    demand_std = demand_std_raw.dropna(subset=['Year'])
    demand_std = demand_std[demand_std['Year'].astype(str).str.startswith('+')].reset_index(drop=True)
    if demand_std.empty:
        raise ValueError("No '+#' rows found in the std dev demand block.")
    product_demand_std = demand_std.iloc[0][PRODUCT_FAMILIES].astype(float)
    product_demand_var = product_demand_std ** 2

    # --- Save cleaned product-level inputs (annual) ---
    demand_avg.to_csv(os.path.join(OUT_DIR, "Product_Demand_Annual_Avg.csv"), index=False)
    demand_std.to_csv(os.path.join(OUT_DIR, "Product_Demand_Annual_StdDev.csv"), index=False)

    # === 2.1) NEW: Product-level WEEKLY avg/std derived from annual ===
    # mean_week = mean_year / 52 ; std_week = std_year / sqrt(52)
    product_weekly_avg = (product_demand_avg / WEEKS_PER_YEAR).rename_axis("Family").reset_index(name="Weekly_Avg_Units")
    product_weekly_std = (product_demand_std / np.sqrt(WEEKS_PER_YEAR)).rename_axis("Family").reset_index(name="Weekly_StdDev_Units")
    product_weekly_avg.to_csv(os.path.join(OUT_DIR, "Product_Demand_Weekly_Avg.csv"), index=False)
    product_weekly_std.to_csv(os.path.join(OUT_DIR, "Product_Demand_Weekly_StdDev.csv"), index=False)

    # === 3) BOM: +1 Year Parts per Product ===
    # Header ≈ row 10 -> header=9
    parts_raw = pd.read_excel(EXCEL_PATH, sheet_name="+1 Year Parts per Product", header=9)
    # Normalize column names to map A1..B2
    rename_map = {
        'Parts per Assembled Product Unit Demanded in Year +1 ': 'A1',
        'Unnamed: 3': 'A2',
        'Unnamed: 4': 'A3',
        'Unnamed: 5': 'B1',
        'Unnamed: 6': 'B2'
    }
    parts_raw = parts_raw.rename(columns=rename_map)
    ensure_cols(parts_raw, ['Part'] + PRODUCT_FAMILIES)
    parts_df = parts_raw[['Part'] + PRODUCT_FAMILIES].dropna(subset=['Part']).reset_index(drop=True)

    # Enforce natural order P1..P20 on BOM
    parts_df = parts_df.set_index('Part').loc[natural_sort_index(parts_df['Part'])].reset_index()
    parts_df.to_csv(os.path.join(OUT_DIR, "Parts_Per_Product_BOM.csv"), index=False)

    # Numeric BOM matrices
    parts_bom = parts_df.set_index('Part').apply(pd.to_numeric, errors='coerce').fillna(0.0)
    parts_bom_sq = parts_bom ** 2

    # === 4) Average parts demand by family (ANNUAL, user-view) ===
    parts_demand_by_family_annual = parts_bom.copy()
    for col in PRODUCT_FAMILIES:
        parts_demand_by_family_annual[col] = parts_demand_by_family_annual[col] * product_demand_avg[col]
    parts_demand_by_family_annual['Total Demand (Annual Avg)'] = parts_demand_by_family_annual[PRODUCT_FAMILIES].sum(axis=1)
    parts_demand_by_family_annual = parts_demand_by_family_annual.loc[natural_sort_index(parts_demand_by_family_annual.index)]
    parts_demand_by_family_annual.to_csv(os.path.join(OUT_DIR, "Parts_Total_Demand_By_Family_AnnualAvg.csv"))

    # === 4.1) NEW: Average parts demand by family (WEEKLY, same layout as AnnualAvg) ===
    parts_demand_by_family_weekly = parts_bom.copy()
    # multiply each family column by the family's weekly average
    weekly_family_avg = (product_demand_avg / WEEKS_PER_YEAR)
    for col in PRODUCT_FAMILIES:
        parts_demand_by_family_weekly[col] = parts_demand_by_family_weekly[col] * weekly_family_avg[col]
    parts_demand_by_family_weekly['Total Demand (Weekly Avg)'] = parts_demand_by_family_weekly[PRODUCT_FAMILIES].sum(axis=1)
    parts_demand_by_family_weekly = parts_demand_by_family_weekly.loc[natural_sort_index(parts_demand_by_family_weekly.index)]
    parts_demand_by_family_weekly.to_csv(os.path.join(OUT_DIR, "Parts_Total_Demand_By_Family_WeeklyAvg.csv"))

    # === 5) Per-part ANNUAL mean & std (linear combination) ===
    s_part_annual_mean = parts_bom.dot(product_demand_avg)   # Units/year
    s_part_annual_mean.name = "Annual_Demand_Mean_Units"

    s_part_annual_var = parts_bom_sq.dot(product_demand_var)
    s_part_annual_std = np.sqrt(s_part_annual_var)           # Units/year
    s_part_annual_std.name = "Annual_Demand_StdDev_Units"

    # === 6) Per-part WEEKLY mean & std ===
    weekly_mean = s_part_annual_mean / WEEKS_PER_YEAR
    weekly_mean.name = "Weekly_Demand_Mean_Units"
    weekly_std = s_part_annual_std / np.sqrt(WEEKS_PER_YEAR)
    weekly_std.name = "Weekly_Demand_StdDev_Units"

    # === 7) Process time (screen-transcribed) & Robust ===
    time_data = {
        'Part': ['P1','P2','P3','P4','P5','P6','P7','P8','P9','P10','P11','P12','P13','P14','P15','P16','P17','P18','P19','P20'],
        'Step 1': [2.5,1.25,1.75,1.0,1.5,0.75,1.0,1.25,1.75,1.5,1.25,1.0,1.25,1.0,0.75,1.25,0.75,0.75,2.25,2.0],
        'Step 2': [1.0,0.5,3.0,2.0,0.75,1.25,1.5,2.0,0.75,1.75,0.5,0.5,1.25,1.5,0.5,5.0,3.0,1.25,2.5,0.75],
        'Step 3': [2.5,2.5,0.75,3.0,3.5,0.5,0.75,0.5,1.25,1.25,1.25,1.0,0.5,0.5,1.25,1.25,3.5,0.5,2.0,3.0],
        'Step 4': [0.5,1.0,1.5,0.25,1.75,3.0,3.5,1.0,0.5,2.0,0.25,1.25,1.0,1.75,2.5,2.5,0.0,3.75,3.75,0.0],
        'Step 5': [2.5,2.5,2.5,1.25,0.0,1.0,1.25,0.0,1.25,0.0,0.75,2.25,0.25,0.0,2.5,0.0,0.0,0.0,0.0,0.0],
        'Step 6': [1.25,0.0,0.0,0.0,0.0,1.25,2.0,0.0,3.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
        'Step 7': [2.5,0.0,0.0,0.0,0.0,2.75,0.0,0.0,0.0,0.0,0.0,0.0,1.25,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
    }
    df_time = pd.DataFrame(time_data).set_index('Part').fillna(0.0)
    s_minutes_per_unit = df_time.sum(axis=1)
    s_minutes_per_unit.name = "Total_Minutes_Per_Unit"

    # Robust = mean + z*std (Annual + Weekly)
    s_robust_annual_units = s_part_annual_mean + Z_SCORE * s_part_annual_std
    s_robust_annual_units.name = "Annual_Robust_Demand_99p5_Units"
    s_robust_weekly_units = weekly_mean + Z_SCORE * weekly_std
    s_robust_weekly_units.name = "Weekly_Robust_Demand_99p5_Units"

    # Robust minutes (Net & Gross) for Annual & Weekly
    s_robust_annual_net_min = s_robust_annual_units * s_minutes_per_unit
    s_robust_annual_net_min.name = "Annual_Robust_Net_Minutes"
    s_robust_annual_gross_min = s_robust_annual_net_min / (EFFICIENCY * RELIABILITY)
    s_robust_annual_gross_min.name = "Annual_Robust_Gross_Minutes"

    s_robust_weekly_net_min = s_robust_weekly_units * s_minutes_per_unit
    s_robust_weekly_net_min.name = "Weekly_Robust_Net_Minutes"
    s_robust_weekly_gross_min = s_robust_weekly_net_min / (EFFICIENCY * RELIABILITY)
    s_robust_weekly_gross_min.name = "Weekly_Robust_Gross_Minutes"

    # === 8) Final per-part table (natural order P1..P20) ===
    df_full = pd.concat([
        s_part_annual_mean,
        s_part_annual_std,
        weekly_mean,
        weekly_std,
        s_robust_annual_units,
        s_robust_annual_net_min,
        s_robust_annual_gross_min,
        s_robust_weekly_units,
        s_robust_weekly_net_min,
        s_robust_weekly_gross_min,
        s_minutes_per_unit
    ], axis=1)
    df_full = df_full.loc[natural_sort_index(df_full.index)]

    # === 9) Write outputs (UPDATED NAMES) ===
    full_out = os.path.join(OUT_DIR, "Task1_Full_Capacity_Annual_Weekly_Robust_Yp1.csv")
    weekly_out = os.path.join(OUT_DIR, "Task1_Per_Part_Weekly_Mean_Std_Robust_Yp1.csv")

    df_full.to_csv(full_out)
    df_full[['Weekly_Demand_Mean_Units',
             'Weekly_Demand_StdDev_Units',
             'Weekly_Robust_Demand_99p5_Units',
             'Weekly_Robust_Net_Minutes',
             'Weekly_Robust_Gross_Minutes']].to_csv(weekly_out)

    # Also keep auxiliary inputs
    print("✅ Done. Outputs saved to:", os.path.abspath(OUT_DIR))
    print(" -", os.path.basename(full_out))
    print(" -", os.path.basename(weekly_out))
    print(" - Product_Demand_Annual_Avg_Yp1.csv")
    print(" - Product_Demand_Annual_StdDev_Yp1.csv")
    print(" - Product_Demand_Weekly_Avg_Yp1.csv")            # NEW
    print(" - Product_Demand_Weekly_StdDev_Yp1.csv")         # NEW
    print(" - Parts_Per_Product_BOM_Yp1.csv")
    print(" - Parts_Total_Demand_By_Family_AnnualAvg_Yp1.csv")
    print(" - Parts_Total_Demand_By_Family_WeeklyAvg_Yp1.csv")  # NEW

if __name__ == "__main__":
    main()
