import pandas as pd
import numpy as np
import math
from typing import Dict, List, Set, Tuple

# ======================================================================
# --- INTEGRATED PROCESS ORGANIZATION FOR TASK 3 ---
# --- Combining Clustering, Replication, and Process Centers ---
# ======================================================================

print("=" * 70)
print("INTEGRATED PROCESS ORGANIZATION SOLUTION")
print("Task 3b: Process Organization with Composite Centers")
print("=" * 70)

# ======================================================================
# --- PART 1: BASE DATA DEFINITIONS ---
# ======================================================================
print("\n--- PART 1: LOADING BASE DATA ---")

# Year +1 Weekly Product Demand
product_demand = pd.Series({
    'A1': 962, 'A2': 1923, 'A3': 2500, 'B1': 1154, 'B2': 1538
}, name="WeeklyProdDemand")

# Bill of Materials (BOM)
bom_data = {
    'P1': {'A1': 1, 'A2': 2, 'A3': 4, 'B1': 4, 'B2': 1},
    'P2': {'A1': 4, 'A2': np.nan, 'A3': 2, 'B1': 2, 'B2': np.nan},
    'P3': {'A1': np.nan, 'A2': np.nan, 'A3': np.nan, 'B1': 4, 'B2': 1},
    'P4': {'A1': np.nan, 'A2': 1, 'A3': 2, 'B1': 2, 'B2': np.nan},
    'P5': {'A1': np.nan, 'A2': 1, 'A3': 2, 'B1': np.nan, 'B2': np.nan},
    'P6': {'A1': 1, 'A2': np.nan, 'A3': np.nan, 'B1': np.nan, 'B2': 2},
    'P7': {'A1': np.nan, 'A2': 4, 'A3': np.nan, 'B1': np.nan, 'B2': 4},
    'P8': {'A1': np.nan, 'A2': np.nan, 'A3': np.nan, 'B1': 4, 'B2': np.nan},
    'P9': {'A1': np.nan, 'A2': 2, 'A3': 2, 'B1': np.nan, 'B2': np.nan},
    'P10': {'A1': 1, 'A2': np.nan, 'A3': 1, 'B1': 1, 'B2': np.nan},
    'P11': {'A1': 2, 'A2': np.nan, 'A3': np.nan, 'B1': np.nan, 'B2': 4},
    'P12': {'A1': 4, 'A2': np.nan, 'A3': np.nan, 'B1': np.nan, 'B2': 4},
    'P13': {'A1': 2, 'A2': np.nan, 'A3': np.nan, 'B1': np.nan, 'B2': 2},
    'P14': {'A1': np.nan, 'A2': 4, 'A3': 2, 'B1': 2, 'B2': 2},
    'P15': {'A1': np.nan, 'A2': np.nan, 'A3': np.nan, 'B1': 2, 'B2': np.nan},
    'P16': {'A1': np.nan, 'A2': 1, 'A3': 4, 'B1': np.nan, 'B2': np.nan},
    'P17': {'A1': 2, 'A2': np.nan, 'A3': np.nan, 'B1': np.nan, 'B2': 2},
    'P18': {'A1': 4, 'A2': 1, 'A3': np.nan, 'B1': np.nan, 'B2': 4},
    'P19': {'A1': np.nan, 'A2': 2, 'A3': 4, 'B1': 4, 'B2': 1},
    'P20': {'A1': np.nan, 'A2': 2, 'A3': 3, 'B1': 3, 'B2': np.nan}
}
bom = pd.DataFrame(bom_data).T.fillna(0).astype(int)

# Process Routes
routes = {
    'P1': ['B', 'A', 'B', 'C', 'D', 'I', 'J'],
    'P2': ['A', 'C', 'D', 'H', 'J'],
    'P3': ['B', 'D', 'C', 'I', 'J'],
    'P4': ['A', 'B', 'D', 'G', 'H'],
    'P5': ['B', 'C', 'D', 'I'],
    'P6': ['A', 'B', 'C', 'D', 'H', 'I', 'J'],
    'P7': ['E', 'F', 'C', 'D', 'I', 'J'],
    'P8': ['E', 'H', 'J', 'I'],
    'P9': ['F', 'G', 'E', 'G', 'I', 'J'],
    'P10': ['E', 'F', 'I', 'J'],
    'P11': ['E', 'G', 'E', 'G', 'I'],
    'P12': ['E', 'G', 'F', 'I', 'J'],
    'P13': ['E', 'F', 'G', 'F', 'G', 'H', 'I'],
    'P14': ['E', 'F', 'G', 'H'],
    'P15': ['E', 'G', 'F', 'H', 'J'],
    'P16': ['F', 'H', 'I', 'J'],
    'P17': ['K', 'L', 'M'],
    'P18': ['K', 'L', 'K', 'M'],
    'P19': ['L', 'M', 'L', 'M'],
    'P20': ['L', 'K', 'M']
}

# Process Times
process_times_data = {
    'P1': [2.5, 1, 2.5, 0.5, 2.5, 1.25, 2.5],
    'P2': [1.25, 0.5, 2.5, 1, 2.5],
    'P3': [1.75, 3, 0.75, 1.5, 2.5],
    'P4': [1, 2, 3, 0.25, 1.25],
    'P5': [1.5, 0.75, 3.5, 1.75],
    'P6': [0.75, 1.25, 0.5, 3, 1, 1.25, 2.75],
    'P7': [1, 1.5, 0.75, 3.5, 1.25, 2],
    'P8': [1.25, 2, 0.5, 1],
    'P9': [1.75, 0.75, 1.25, 0.5, 1.25, 3],
    'P10': [1.5, 1.75, 1.25, 2],
    'P11': [1.25, 0.5, 1.25, 0.25, 0.75],
    'P12': [1, 0.5, 1, 1.25, 2.25],
    'P13': [1.25, 1.25, 0.5, 1, 0.25, 2, 1.25],
    'P14': [1, 1.5, 0.5, 1.75],
    'P15': [0.75, 0.5, 1.25, 2.5, 2.5],
    'P16': [1.25, 5, 1.25, 2.5],
    'P17': [0.75, 3, 3.5],
    'P18': [0.75, 1.25, 0.5, 3.75],
    'P19': [2.25, 2.5, 2, 3.75],
    'P20': [2, 0.75, 3]
}

part_operations = {}
for part in routes.keys():
    part_operations[part] = list(zip(routes[part], process_times_data[part]))

# Equipment Data
equipment_data = {
    'A': {'Price': 150000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'B': {'Price': 200000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'C': {'Price': 250000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'D': {'Price': 300000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'AB': {'Price': 250000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'AC': {'Price': 280000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'CD': {'Price': 350000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'ABC': {'Price': 300000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'ABCD': {'Price': 400000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0.25, 'C3': 0}},
    'E': {'Price': 400000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0, 'C3': 0.5}},
    'F': {'Price': 400000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0, 'C3': 0.5}},
    'G': {'Price': 400000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0, 'C3': 0.5}},
    'EF': {'Price': 450000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0, 'C3': 0.5}},
    'EG': {'Price': 450000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0, 'C3': 0.5}},
    'FG': {'Price': 450000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0, 'C3': 0.5}},
    'EFG': {'Price': 500000, 'Life': 10, 'Ops': {'C1': 1, 'C2': 0, 'C3': 0.5}},
    'H': {'Price': 1000000, 'Life': 15, 'Ops': {'C1': 0, 'C2': 0, 'C3': 2}},
    'I': {'Price': 500000, 'Life': 15, 'Ops': {'C1': 0, 'C2': 0, 'C3': 2}},
    'J': {'Price': 500000, 'Life': 15, 'Ops': {'C1': 0, 'C2': 0, 'C3': 2}},
    'IJ': {'Price': 750000, 'Life': 15, 'Ops': {'C1': 0, 'C2': 0, 'C3': 2}},
    'K': {'Price': 80000, 'Life': 8, 'Ops': {'C1': 0, 'C2': 0.5, 'C3': 0}},
    'L': {'Price': 100000, 'Life': 8, 'Ops': {'C1': 0, 'C2': 0.5, 'C3': 0}},
    'M': {'Price': 50000, 'Life': 8, 'Ops': {'C1': 0, 'C2': 0.5, 'C3': 0}},
    'KL': {'Price': 140000, 'Life': 8, 'Ops': {'C1': 0, 'C2': 0.5, 'C3': 0}},
    'KM': {'Price': 100000, 'Life': 8, 'Ops': {'C1': 0, 'C2': 0.5, 'C3': 0}},
    'LM': {'Price': 120000, 'Life': 8, 'Ops': {'C1': 0, 'C2': 0.5, 'C3': 0}},
    'KLM': {'Price': 150000, 'Life': 8, 'Ops': {'C1': 0, 'C2': 0.5, 'C3': 0}}
}
equipment_df = pd.DataFrame.from_dict(equipment_data, orient='index')

# Constants
SHIFTS = 1  # Can be 1 or 2
MINUTES_PER_WEEK_RAW = 8 * 60 * 5 * SHIFTS
EFFICIENCY = 0.90
RELIABILITY = 0.98
EFFECTIVE_MINUTES_PER_MACHINE = MINUTES_PER_WEEK_RAW * EFFICIENCY * RELIABILITY
ANNUAL_HOURS_PER_OPERATOR = (8 * 5) * 49

print("Base data loaded successfully.\n")

# ======================================================================
# --- PART 2: PRODUCTION FLOW ANALYSIS ---
# ======================================================================
print("--- PART 2: PRODUCTION FLOW ANALYSIS ---")

# Calculate weekly part demand
part_demand_weekly = bom.dot(product_demand)
print("Weekly Part Demand:")
print(part_demand_weekly.to_string())
print()

# Build From-To Flow Matrix
all_processes = set()
for route in routes.values():
    all_processes.update(route)
sorted_processes = sorted(list(all_processes))

matrix_nodes = ['START'] + sorted_processes + ['END']
from_to_matrix = pd.DataFrame(0, index=matrix_nodes, columns=matrix_nodes)

for part, route_list in routes.items():
    demand = part_demand_weekly[part]
    if demand > 0:
        from_to_matrix.loc['START', route_list[0]] += demand
        for i in range(len(route_list) - 1):
            from_proc = route_list[i]
            to_proc = route_list[i+1]
            from_to_matrix.loc[from_proc, to_proc] += demand
        from_to_matrix.loc[route_list[-1], 'END'] += demand

# ======================================================================
# --- PART 3: ENHANCED CLUSTERING WITH REPLICATION ---
# ======================================================================
print("--- PART 3: ENHANCED CLUSTERING WITH REPLICATION ---")

def roc_order(matrix):
    """Apply Rank Order Clustering algorithm"""
    matrix = matrix.copy()
    n = matrix.shape[0]
    weights = 2**(np.arange(n - 1, -1, -1))
    iteration = 0
    max_iterations = n * 2
    
    while iteration < max_iterations:
        iteration += 1
        old_row_order = list(matrix.index)
        
        # Sort rows
        row_scores = matrix.dot(weights)
        new_row_order = row_scores.sort_values(ascending=False).index
        matrix = matrix.loc[new_row_order, :]
        
        # Sort columns
        col_scores = matrix.T.dot(weights)
        new_col_order = col_scores.sort_values(ascending=False).index
        matrix = matrix.loc[:, new_col_order]
        
        if list(new_col_order) == old_row_order:
            break
    
    return list(matrix.index)

def split_into_centers(ordered_processes, interaction_matrix, max_size=5):
    """Split ordered processes into centers based on interaction strength"""
    centers = []
    current_center = []
    
    for i, proc in enumerate(ordered_processes):
        current_center.append(proc)
        
        # Check if we should break here
        if len(current_center) >= max_size:
            centers.append(current_center)
            current_center = []
        elif i < len(ordered_processes) - 1:
            next_proc = ordered_processes[i + 1]
            interaction = interaction_matrix.loc[proc, next_proc] if proc in interaction_matrix.index and next_proc in interaction_matrix.columns else 0
            if interaction == 0:  # Natural break point
                centers.append(current_center)
                current_center = []
    
    if current_center:
        centers.append(current_center)
    
    return centers

# Create interaction matrix
core_flow = from_to_matrix.loc[sorted_processes, sorted_processes]
interaction_matrix = core_flow + core_flow.T

# Define process families based on equipment categories
families = {
    'F1': ['A', 'B', 'C', 'D'],      # ABCD family
    'F2': ['E', 'F', 'G'],            # EFG family
    'F3': ['H', 'I', 'J'],            # HIJ family
    'F4': ['K', 'L', 'M']             # KLM family
}

print("\nProcess Families:")
for fam_id, procs in families.items():
    print(f"  {fam_id}: {procs}")

# ======================================================================
# --- PART 4: REPLICATION ANALYSIS ---
# ======================================================================
print("\n--- PART 4: REPLICATION ANALYSIS ---")

# Calculate process-to-cluster affinity shares
proc2cluster = {}
initial_clusters = []

# First pass: create initial clusters by family
for fam_id, fam_procs in families.items():
    fam_procs_in_factory = [p for p in fam_procs if p in sorted_processes]
    if fam_procs_in_factory:
        sub_interaction = interaction_matrix.loc[fam_procs_in_factory, fam_procs_in_factory]
        ordered = roc_order(sub_interaction)
        centers = split_into_centers(ordered, sub_interaction, max_size=3)
        for center in centers:
            initial_clusters.append(center)
            for proc in center:
                proc2cluster[proc] = len(initial_clusters) - 1

print("\nInitial Clusters (before replication):")
for i, cluster in enumerate(initial_clusters):
    print(f"  Cluster {i}: {cluster}")

# Calculate inter-cluster interaction shares
proc2cluster_share = {}
for p in sorted_processes:
    shares = {}
    row = interaction_matrix.loc[p]
    for q, val in row.items():
        if q == p or val <= 0:
            continue
        target_cluster = proc2cluster.get(q, -1)
        if target_cluster >= 0:
            shares[target_cluster] = shares.get(target_cluster, 0) + val
    
    total = sum(shares.values())
    if total > 0:
        proc2cluster_share[p] = {k: v/total for k, v in shares.items()}
    else:
        proc2cluster_share[p] = {}

# Determine replication needs
TAU = 0.70      # Single dominant cluster threshold
S_MIN = 0.25    # Minimum share for replication
MAX_REPLICAS = 3

replica_targets = {}
for p, share in proc2cluster_share.items():
    if not share:
        replica_targets[p] = [proc2cluster[p]]
        continue
    
    sorted_shares = sorted(share.items(), key=lambda x: x[1], reverse=True)
    
    # Check if one cluster dominates
    if sorted_shares and sorted_shares[0][1] >= TAU:
        replica_targets[p] = [sorted_shares[0][0]]
    else:
        # Select clusters with sufficient share
        candidates = [cid for cid, s in sorted_shares if s >= S_MIN][:MAX_REPLICAS]
        replica_targets[p] = candidates if candidates else [proc2cluster[p]]

print("\nReplication Analysis:")
for proc, targets in replica_targets.items():
    if len(targets) > 1:
        shares_str = ", ".join([f"C{t}: {proc2cluster_share[proc].get(t, 0):.2%}" for t in targets])
        print(f"  Process {proc} replicated to clusters {targets} (shares: {shares_str})")

# ======================================================================
# --- PART 5: CREATE FINAL COMPOSITE CENTERS ---
# ======================================================================
print("\n--- PART 5: FINAL COMPOSITE PROCESS CENTERS ---")

# Build expanded nodes with replicas
expanded_nodes = []
replica_name = {}
for p, target_clusters in replica_targets.items():
    for cluster_id in target_clusters:
        name = f"{p}@C{cluster_id}" if len(target_clusters) > 1 else p
        replica_name[(p, cluster_id)] = name
        expanded_nodes.append((name, cluster_id, p))

# Group by cluster and create composite centers
final_centers = {}
for node_name, cluster_id, base_proc in expanded_nodes:
    if cluster_id not in final_centers:
        final_centers[cluster_id] = {
            'processes': [],
            'base_processes': set(),
            'workload': 0,
            'family': None
        }
    final_centers[cluster_id]['processes'].append(node_name)
    final_centers[cluster_id]['base_processes'].add(base_proc)
    
    # Determine family
    for fam_id, fam_procs in families.items():
        if base_proc in fam_procs:
            final_centers[cluster_id]['family'] = fam_id
            break

print("\nFinal Composite Process Centers:")
for cid, center_data in final_centers.items():
    base_procs = sorted(center_data['base_processes'])
    composite_name = ''.join(base_procs)
    print(f"\nCenter {cid} ({composite_name} Center):")
    print(f"  Family: {center_data['family']}")
    print(f"  Base Processes: {base_procs}")
    if len(center_data['processes']) != len(base_procs):
        print(f"  Including Replicas: {center_data['processes']}")

# ======================================================================
# --- PART 6: WORKLOAD AND RESOURCE ANALYSIS ---
# ======================================================================
print("\n--- PART 6: WORKLOAD AND RESOURCE ANALYSIS ---")

# Calculate workload per process
total_workload = pd.Series(0.0, index=all_processes)
for part, operations in part_operations.items():
    demand = part_demand_weekly[part]
    if demand > 0:
        for process, time in operations:
            total_workload[process] += demand * time

print("\nTotal Workload by Process (minutes/week):")
for proc in sorted_processes:
    print(f"  {proc}: {total_workload[proc]:,.0f} min/week")

# Analyze each composite center
print("\n" + "=" * 70)
print("COMPOSITE CENTER OPTIMIZATION ANALYSIS")
print("=" * 70)

def annualized_cost(price, life, r=0.10):
    crf = r * (1 + r)**life / ((1 + r)**life - 1)
    return price * crf

operator_hourly_cost = {'C1': 20, 'C2': 40, 'C3': 60}

for cid, center_data in final_centers.items():
    base_procs = sorted(center_data['base_processes'])
    composite_name = ''.join(base_procs)
    
    print(f"\n{'='*50}")
    print(f"Center {cid}: {composite_name} Composite Center")
    print(f"{'='*50}")
    
    # Calculate center workload (considering replication shares)
    center_workload = 0
    for proc in base_procs:
        base_workload = total_workload[proc]
        # Adjust for replication if needed
        if len(replica_targets[proc]) > 1:
            share = 1.0 / len(replica_targets[proc])  # Simplified equal sharing
            center_workload += base_workload * share
        else:
            center_workload += base_workload
    
    print(f"Total Center Workload: {center_workload:,.0f} min/week")
    
    # Option 1: Dedicated machines
    print("\n--- Option 1: DEDICATED Machines ---")
    total_dedicated_cost = 0
    dedicated_machines = {}
    
    for proc in base_procs:
        proc_workload = total_workload[proc]
        if len(replica_targets[proc]) > 1:
            proc_workload *= 1.0 / len(replica_targets[proc])
        
        machines_needed = math.ceil(proc_workload / EFFECTIVE_MINUTES_PER_MACHINE)
        dedicated_machines[proc] = machines_needed
        
        # Calculate cost
        equip_data = equipment_df.loc[proc]
        annual_inv = annualized_cost(equip_data['Price'], equip_data['Life'])
        ops_cost = (equip_data['Ops']['C1'] * operator_hourly_cost['C1'] * ANNUAL_HOURS_PER_OPERATOR +
                   equip_data['Ops']['C2'] * operator_hourly_cost['C2'] * ANNUAL_HOURS_PER_OPERATOR +
                   equip_data['Ops']['C3'] * operator_hourly_cost['C3'] * ANNUAL_HOURS_PER_OPERATOR)
        total_annual = (annual_inv + ops_cost) * machines_needed
        total_dedicated_cost += total_annual
        
        print(f"  {machines_needed} x {proc}: ${total_annual:,.0f}/year")
    
    print(f"  Total Dedicated Cost: ${total_dedicated_cost:,.0f}/year")
    
    # Option 2: Flexible composite machine
    print(f"\n--- Option 2: FLEXIBLE Composite Machine ({composite_name}) ---")
    
    if composite_name in equipment_df.index:
        machines_flex = math.ceil(center_workload / EFFECTIVE_MINUTES_PER_MACHINE)
        
        equip_data = equipment_df.loc[composite_name]
        annual_inv = annualized_cost(equip_data['Price'], equip_data['Life'])
        ops_cost = (equip_data['Ops']['C1'] * operator_hourly_cost['C1'] * ANNUAL_HOURS_PER_OPERATOR +
                   equip_data['Ops']['C2'] * operator_hourly_cost['C2'] * ANNUAL_HOURS_PER_OPERATOR +
                   equip_data['Ops']['C3'] * operator_hourly_cost['C3'] * ANNUAL_HOURS_PER_OPERATOR)
        total_flex_cost = (annual_inv + ops_cost) * machines_flex
        
        print(f"  {machines_flex} x {composite_name}: ${total_flex_cost:,.0f}/year")
        
        # Recommendation
        print("\n  --- Recommendation ---")
        if total_flex_cost < total_dedicated_cost:
            savings = total_dedicated_cost - total_flex_cost
            print(f"  FLEXIBLE strategy is better (saves ${savings:,.0f}/year)")
            center_data['strategy'] = 'FLEXIBLE'
            center_data['machines'] = f"{machines_flex} x {composite_name}"
            center_data['cost'] = total_flex_cost
        else:
            savings = total_flex_cost - total_dedicated_cost
            print(f"  DEDICATED strategy is better (saves ${savings:,.0f}/year)")
            center_data['strategy'] = 'DEDICATED'
            center_data['machines'] = dedicated_machines
            center_data['cost'] = total_dedicated_cost
    else:
        print(f"  Composite machine {composite_name} not available")
        print("  Using DEDICATED strategy by default")
        center_data['strategy'] = 'DEDICATED'
        center_data['machines'] = dedicated_machines
        center_data['cost'] = total_dedicated_cost

# ======================================================================
# --- PART 7: FINAL SUMMARY ---
# ======================================================================
print("\n" + "=" * 70)
print("FINAL PROCESS ORGANIZATION SUMMARY")
print("=" * 70)

total_cost = sum(center['cost'] for center in final_centers.values())
print(f"\nTotal Number of Centers: {len(final_centers)}")
print(f"Total Annual Cost: ${total_cost:,.0f}")

print("\nCenter Configuration:")
for cid, center_data in final_centers.items():
    base_procs = sorted(center_data['base_processes'])
    print(f"\n  Center {cid} ({center_data['family']}):")
    print(f"    Processes: {base_procs}")
    print(f"    Strategy: {center_data['strategy']}")
    print(f"    Equipment: {center_data['machines']}")
    print(f"    Annual Cost: ${center_data['cost']:,.0f}")

print("\n" + "=" * 70)
print("ANALYSIS COMPLETE")
print("=" * 70)
